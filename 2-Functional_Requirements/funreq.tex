\chapter{Modelling Sardex Payment Operations\\ (Functional Requirements)}
\label{ch:funreq}


\vspace{-1cm}
\begin{center}
Egon B\"orger
%, Luca Carboni, Massimeddu Cireddu, Paolo Dini, Eduard Hirsch
\end{center}


Hi!

\noindent\fbox{\parbox{\textwidth}{
\textcolor{brown}{
{\bf Notes:}\\
- Boxed answers to questions are at the end\\
- Additional comments interspersed in the text as footnotes\\
\textcolor{red}{- Egon: red}\\
\textcolor{purple}{- Massi: purple}\\
\textcolor{green}{- Luca: green}\\
\textcolor{brown}{- Paolo: brown}\\
\textcolor{blue}{- Eduard: blue}
}}}
\vspace{12pt}

We specify the core payment and related history operations of the Sardex system. We do this at the functional requirements  level of abstraction and in a component-based manner so that the resulting model can serve as abstract description of the current implementation but also as starting point for a new, blockchain-based implementation.

We consider here B2B operations, leaving the consideration of operations between business and either employees or consumers for a later phase.

\section{Core Payment Operations}

\subsection{Signature of B2B Operations}
The actors of B2B operations are companies which interact via the Sardex system. We focus here on modelling the actions the Sardex system performs when triggered by requests sent to it by any company of the circuit. In other words, we specify the behaviour of Sardex, formulated as an Abstract State Machine (ASMs) that is executed by what we call a Sardex agent.\footnote{Observe that in a non-monolithic version of the Sardex system different instances of the system are run by different agents which all execute the same program (or a program that has been obtained by adapting the basic program appropriately for a particular instance.) .} We describe the iteraction of companies with the Sardex system by $\ASM{Send}$ and $\ASM{Receive}$ actions of communicating ASMs.\footnote{\textcolor{brown}{(Paolo) Are communicating ASMs the same as ASIMs? I am perfectly happy talking about the ASM methodology and using ASM as the general concept, but when appropriate we should say `ASIM' just for the sake of clarity.}}

The core payment operations are sent to Sardex by companies $c \in SardexNet$. Each such company may have a number of accounts which we represent as elements of a set $Account(c)$. Each account is of some type out of the set $AccountType$ of possible account types:

\begin{asm}
AccountType=\{credit, domu, fee\}
\end{asm}

Therefore we name such accounts 
$creditAccount(c)$, $domuAccount(c)$, $feeAccount(c)$ (if $c$ has them). 

There are two principal transfer operations, called Credit operation and Debit operation, respectively.

\subsection{Credit Operation}

A Credit operation is also called a push transfer. Its goal is to transfer an $amount$ via a specific $channel$ from one account, specified as the $origin$ (or source) of the transfer, to another one indicated as the transfer $destination$ (or target). Sardex uses a $TransferType$ concept which allows one to impose on the transfer operations certain conditions, including priorities. The parameters of a transfer type $tt$ are 

\begin{itemize}
	\item the $operation \in \{Credit, Debit\}$,
	\item the $channel$ (e.g. phone or website) through which the interaction between the user and the Sardex system takes place,
	\item the two involved accounts $from$, $to$,
	\item conditions on the to-be-transferred $amount$.
\end{itemize}

We retrieve for each parameter the corresponding information from a transfer type $tt$ by appropriate functions:
\begin{asm}
oper,chan,source,target,amountCond
\end{asm}
One can imagine $TransferType$ as a table where each row is named and has the form\footnote{\textcolor{brown}{(Paolo) Note that we have three ways to denote to and from accounts: $(to, from)$, $(source, target)$, $(originAcc, destAcc)$. Unless I misunderstood something, I suggest we pick one...}}
\begin{asm}
(name,operation,channel,originAcc,destAcc,amountCondition)\\
\WHERE \+
   operation \in \{credit, debit\}\\
   channel \in \{phone,website\}
\end{asm}

\textcolor{red}{***QUESTION 1 to Massi: in your notes I found the statement that $TransferType$ is defined in such a way as to guarantee that 
\begin{quote} 
	for each pair of accounts $acc,acc'$ there is at most one $tt \in AccountType$ 
\end{quote}
which would mean at most one $tt$ with $source(tt)=acc$ and $target(tt)=source'$ or vice versa. Is this true? Is it not possible to perform a Credit operation from acc to acc' and a Debit operation from acc to acc' or from $acc'$ to $acc$?***}
\vspace{12pt}

Both payment operations Credit and Debit have two phases, one whose action is called Preview where only the permission for the transfer is checked but not the requested amount, and the other whose action is called Perform where also the amount is checked. Since both actions are treated as stateless on the user side, the two-phase character implies a two-phase request/response scheme between the user and the Sardex system.

Various notations are available to make the sequential character of two successive steps explicit in the context of the parallel computation model of ASMs. One is to use a traditional flowchart definition (which visualizes the explicit introduction of successive $mode$ or $phase$ values and ends up definining what are control-state ASMs). Another one is to use the $\STEP$ operator for ASMs which is defined in such a way that in two successive executions of $M \STEP N$, in the first step $M$ and in the second step $N$ is executed, in the next execution of  $M \STEP N $ again $M$, etc. Here we make the -- for the user stateless -- two-phase communication exchange explicit by using two operations, one for the transfer Preview and one to Perform the transfer. Thus we assume the user to first send a $CreditPreviewReq$uest and upon the positive system response the corresponding $CreditPerformReq$uest.


\vspace{12pt}
\textcolor{red}{***QUESTION 2: Should we worry at this stage that for an executable version of the model we also need a model for the corresponding user actions? For the time being we are formulating only the rules for the Sardex agent.}
***
\vspace{12pt}

The function $availBalance(acc)$ yields the amount of money that is currently available on the $acc$ to be spent. It is defined together with the related current balance function $balance(acc)$ in Sect.~\ref{sect:accHistory}. $Receivable(amount,acc)$ checks whether the destination of the transfer by receiving the $amount$ would exceed its upper Sardex limit
$upperLimit(acc)$.\footnote{\textcolor{brown}{(Paolo) What is the difference between $acc$ and $Account(c)$?}}

\vspace{12pt}
\textcolor{red}{
***QUESTION 3 to Luca/Massi: how do you want this function to be named?***}
\vspace{12pt}

The function $transaction(tt)$ yields the transaction corresponding to the transfer type $tt$.

\vspace{12pt}
\textcolor{red}{***QUESTION 4 to Luca/Massi: is this abstraction  correct, namely to compute the transition from the transfer parameter?For Debit I included an additional parameter $pending$.***}
\vspace{12pt}

\begin{asm}
\ASM{CreditTransferReq}((from, to, amount, channel),mbr)=\+
\LET transfer=(credit,channel,from,to,amount) \\
\IF  Received(CreditPreviewReq(from, to, amount, channel),from:mbr) \THEN \+  
   \LET res=transferTypeCheck(transfer)  \+
      \IF res = error \THEN ~ \ASM{Send}(ErrMsg(NotPermitted(transfer)),to:mbr)\\
      \IF res=ok \THEN ~ \ASM{Send}(YouMayProceedWith(transfer),to:mbr)\dec\-
\IF  Received(CreditPerformReq(from, to, amount, channel),from:mbr) \THEN \+     
      \LET bal = balanceCheck(from, to, amount) \+
           \IF bal=ok \THEN ~ \ASM{Append}(transaction(transfer),Ledger)\+
              \ELSE ~ \ASM{Send}(ErrMsg((transfer,bal),to:mbr)\dec\dec\-
\WHERE \+
  transferTypeCheck(transfer)=\+
          ok \IF ~ \FORSOME tt \in TransactionType ~~  Match(tt,transfer)\\
          error \ELSE \-
  \LET transfer=(credit,channel,from,to,amount) \+
       Match(tt,transfer) \mbox{ iff } oper(tt)=credit \AND chan(tt)=channel \AND \+
             source(tt)=from \AND target(tt)=to \AND amountCond(tt)(amount)=true\dec\-
  balanceCheck(from, to, amount) = \+
        ok ~ \IF availBalance(from) \geq amount \AND Receivable(amount,to)\\
        NotAvailOnAcc(from,amount) \+
           \IF availBalance(from) < amount \AND Receivable(amount,to)\-
        MakesExceedAccLimit(to,amount) \+
          \IF availBalance(from) \geq amount \AND~\NOT Receivable(amount,to)\-
        NotAvailOnAcc(from,amount) \AND MakesExceedAccLimit(to,amount)  \+
          \IF availBalance(from) < amount \AND~\NOT Receivable(amount,to)\dec\-
    Receivable(amt,acc) \mbox{ iff } balance(acc) + amt \leq upperLimit(acc)
\end{asm}

\vspace{12pt}
\textcolor{red}{***QUESTION 5 to Luca/Massi: do you want the $transferTypeCheck(tt)$ to yield more than OK/notOK to be able to give more details in the ErrMsg, the way shown for balanceCheck? If yes, which details do you want to specify here?***}
\vspace{12pt}

In the $\ASM{CreditTransferReq}$ model we assume that its access to the two accounts $from, to$ is exclusive; in other words, we abstract here from the corresponding synchronization mechanism which guarantees the assumption.

\vspace{12pt}
\textcolor{red}{***QUESTION 6 to Luca/Massi: I believe to remember that one of you said that upon receiving the CreditPerformReq the system executes once more the transferTypeCheck. Is this the case or is the result of the previously performed check stored and retrieved? Whatever your answer is, you probably consider this as an important requirement we should express in the ground model?***}
\vspace{12pt}

\textcolor{red}{***QUESTION 7 to Luca/Massi: I guess that where a response to a request is expected there is a timeout mechanism to prevent the system to expect infinitely long for an answer. If this is true and if you want to express it in the spec we should insert a timeout mechanism into the corresponding rule. Please let me know whether I should do this.***}
\vspace{12pt}

\subsection{Debit Operation}
Similarly to Credit operations, also a Debit operation as its first step makes a $transferTypeCheck$, defined as above but extending the $Match$ predicate for debit transfers. If the check succeeds, a two-phase request/response interaction is started, this time between the system and the user. Thus upon receiving the $DebitPerformReq$uest the system executes the $balanceCheck$, for which we use the same abstract function as for Credit operations but with interchanged source/target parameters; in other words, it is checked\footnote{\textcolor{brown}{(Paolo) I think you mean `The Sardex ASM agent checks...' or `The system checks...'}} whether from the account that should be debited a corresponding Credit operation can be performed. If this check succeeds the system inserts the transaction without further ado if the amount is small (less than 100). Otherwise it inserts the transaction as pending and creates an element $otp$ of $OneTimePassword$ that is sent to the requestor with an acknowledgement request. When this $otp$ is resent by the requestor\footnote{\textcolor{brown}{(Paolo) Note that in the answer to Q1 we considered using `originator' instead of `requestor'. We should decide which one we want.}} the system updates the transaction status from $pending$ to $performed$.

\vspace{12pt}
\textcolor{red}{***QUESTION 8 to Luca/Massi: Do pending transaction go into the Ledger? For the time being I guess yes since when the system is waiting for an $otp$ confirmation the user is expected to answer, the user may instead try to make another Credit transfer: it could be that only one, Credit or Debit, is still possible due to the user's account balance. But probably the system on this issue offers some more complexity you may want to explain to us.***}
\vspace{12pt}

\textcolor{red}{***QUESTION 9 to Luca/Massi: How much time do you allow between sending the $otp$ and its acknowledgement, in other words for a transaction to remain pending? Is it possible to change channel, using one for CreditPreviewReq and another one for the acknowledgement of the $otp$?***}
\vspace{12pt}

\begin{asm}
\ASM{DebitTransferReq}((from, to, amount, channel),mbr)=\+
\IF  Received(DebitPreviewReq(from, to, amount, channel),from:mbr) \THEN \+  
   \LET transfer=(debit,channel,from,to,amount)    \\
   \LET res=transferTypeCheck(transfer) \+
      \IF res = error \THEN ~ \ASM{Send}(ErrMsg(NotPermitted(transfer)),to:mbr)\\
      \IF res=ok \THEN ~ \ASM{Send}(YouMayProceedWith(transfer),to:mbr)\dec\-
\IF  Received(DebitPerformReq(from, to, amount, channel),from:mbr) \THEN \+     
  \LET transfer=(debit,channel,from,to,amount)  \\
  \LET bal = balanceCheck(to, from, amount) \+
      \IF bal \not =ok \THEN ~ \ASM{Send}(ErrMsg((transfer,bal),to:mbr)   \ELSE \+
         \IF Small(amount) \THEN ~ \ASM{Append}(transaction(tt),Ledger) \ELSE \+
            \ASM{Append}(transaction(transfer,pending),Ledger) \\        
            \LET otp= \NEW(OneTimePassword) \+
               \ASM{Send}(ConfirmationReq(transfer,otp),to:mbr)\dec\dec\dec\dec\-
\IF  Received(DebitAckMsg(from, to, amount, channel,otp),from:mbr) \THEN \+ 
     \LET t=transaction(debit,channel,from,to,amount,pending) \+
           status(t):=performed \dec\-       
\WHERE \+
Small(amount) \mbox{ iff } amount<100 \\
 \LET transfer=(debit,channel,from,to,amount) \+
     Match(tt,transfer) \mbox{ iff } oper(tt)=credit \AND chan(tt)=channel \AND \+
        source(tt)=to \AND target(tt) =  from \AND amountCond(tt)(amount)=true
\end{asm}

\vspace{12pt}
\textcolor{red}{***QUESTION 10 to Luca/Massi: I vaguely remember that there was an issue whether in Debit Request the parameters from/to denote accounts or members, but I do not remember what is the case in your system. If from/to are members, the above from/to must become the corresponding account (but which one?) of the members.***}
\vspace{12pt}

\section{Permission Features}
\section{Account History and Balance Operations}
\label{sect:accHistory}

The Sardex system accepts from every member $mbr \in SardexNet$ an account history request for any of its accounts, i.e. the elements of  the set $Account(mbr)$.\footnote{\textcolor{brown}{(Paolo) Possible inconsistency: above we used $Account(c)$.}} As parameters of such a request the member can indicate besides the $acc$ount also the $period \in Period$ for which the history is requested, the counterparty (an element of the set $CounterParty(mbr)$  of accounts allowed to be accessed by the member for a transfer), and/or the amount range in the set $AmountRange$ of allowed transfer amounts, as well as some custom field (an element of the set $CustField$).\footnote{\textcolor{brown}{(Paolo) Is this meant to be singular? i.e.\ only 1 custom field?}}

The information requested by the parameters is retrieved by the Sardex system applying corresponding functions to transactions. A  history request is about transactions $t$ in the $Ledger$, where the $acc$ount appears as $origin(t)$ -- the account from where the $t$-transfer has been made -- or as $dest(t)$, the account where the $t$-transfer has been directed to; here $origin$ and $dest$ 
indicate the corresponding extraction functions applied to transactions.\footnote{\textcolor{brown}{(Paolo) Not sure if I am missing something, but it looks like we now have a 4th way to name to/from accounts... See Footnote 3.}} The function $date(t)$ extracts the date of the transaction; for the to-be-reported transactions this date must be within the indicated $period$. The function $counterParty(t, acc)$ extracts from a transaction the other account and is applied in case the $counterPty$ parameter is not ALL. The function $amount(t)$  extracts the amount of a transaction; this amount is required to be in the indicated $amountRange$. A complex $Match$ condition expresses the relation which is requested to hold between the $custField$ parameter and the custom fields extracted by the function $customField(t)$. 

\vspace{12pt}
\textcolor{red}{***QUESTION 11: Can the $counterPty$ parameter indicate besides ALL and a specific account also a set of accounts (or a set of members whose accounts are involved in a transaction)? Or does the parameter anyway indicate not an account but a member? In those cases the rule should be adapted.***}
\vspace{12pt}

The Sardex system answers an $AccountHistReq$est by sending back to the requestor either an error message -- in case the requestor is not a member of the circuit or the indicated account is not one of its accounts -- or the set $T$ of transactions which satisfy the above-indicated properties. This is specified by the ASM rule below. Note that by processing the request message received the Sardex system $\ASM{Consume}$s it.


In the ASM rule below $Received(msg,from\colon s)$ is a predicate which is true when the message $(msg)$ from the sender $s$ (here a member of the Sardex net) is in the $mailbox$ of the receiving agent (here the Sardex agent). $\ASM{Consume}(msg)$ denotes the operation of deleting the $msg$ from the $mailbox$ once it is processed. $\ASM{Send}(msg,to\colon a)$ denotes the operation of sending the $msg$ to agent $a$, here the member $mbr$ who did $\ASM{Send}$ the request. 

We usually assume  each $msg \in Message$ to contain besides its $payload(msg)$ also the information about its $sender(msg)$ and $receiver(msg)$. Thus the parameter $from:mbr$ in $Received(msg,from\colon mbr)$ indicates that $sender(msg)=mbr$, similarly $to:mbr$ in $\ASM{Send}(msg,to\colon mbr)$ denotes that\\ $receiver(msg) = mbr$.

\begin{asm}
\ASM{AccountHistReq}=\+
   \IF Received(AccountHistReq(acc, period, counterPty, amountRange, custField),from\colon mbr)\\
   \THEN \+
     \IF mbr \not \in SardexNet \OR acc \not\in Account(mbr) \+
       \THEN \ASM{Send}(ErrMsg(youHaveNoSuch(acc)),to\colon mbr)\\
       \ELSE ~ \LET T=\{t \in Ledger \mid (origin(t) = acc \OR dest(t) = acc) \+
           \AND date(t) \in period \AND amount(t) \in amountRange \\
           \AND (\IF counterPty \not = All \THEN 
                counterPty = counterParty(t, acc))\\
           \AND Match(custField, customField(t)) \} \IN \+
                \ASM{Send} (T, Member)\dec\dec\-
     \ASM{Consume}(AccountHistReq(acc, period, counterPty, amountRange, custField))
\end{asm}

In a similar way, one can specify the behaviour of the Sardex system when it receives a $BalanceReq$uest, namely to compute the current $balance$ of the requestor's account. This computation computes the sum of the amounts of each received transfer and detracts from it the sum of the amounts of each sent transfer.

In addition, we forsee that, for performance and database management reasons, from time to time the system issues a $certifiedBal$ance. Therefore to calculate the current $balance(acc)$, starting with the last $certifiedBal$ance of this $acc$ount, only those transactions need to be considered whose $date$ is after the last $balanceCertificationDate(acc)$, a dynamic location the system updates to the system time $now$ each time it updates the value of the location $certifiedBal(acc)$. This is expressed by the following ASM rule:

\begin{asm}
\ASM{BalanceReq}=\+
 \IF Received(BalanceReq(acc)),from:mbr) \THEN \+
      \IF  mbr \not \in SardexNet \OR acc \not\in Account(mbr) \+     
         \THEN ~ \ASM{Send}(ErrMsg(youHaveNoSuch(acc)),to:mbr)\\
         \ELSE  \+
             \LET In= \{t \in Ledger \mid dest(t) = acc 
                  \AND date(t) > balCertificationDate(acc) \} \+
                          \mbox{ // case receive}\-
             \LET Out= \{t \in Ledger \mid origin(t) = acc  
             \AND date(t) > balCertificationDate(acc) \} \+
                  \mbox{ // case transfer}\-
             \LET bal=  
                \sum_{t \in In} amount(t)   -  \sum_{t \in Out} amount(t)
                  + certifiedBal(acc)  \\
              \LET NoOfTransactions =  \mid In \mid + \mid Out \mid) \+
             \ASM{Send} ((bal,NoOfTransactions,to:mbr) \dec\dec\-
         \ASM{Consume}(BalanceReq(acc))
\end{asm}

Having the $balance$, one can compute the $availBalance$ (the spendable amount) by adding the value of the $creditLine$:
\begin{asm}
availBalance(acc)= balance(acc)+creditLine(acc)
\end{asm}

$availBalance$ is an example of a derived function, i.e. a dynamic function with a fixed computation scheme (here an equation).  $creditLine(acc)$ is a monitored function for members, it is a controlled function for the agent (typically a broker) who has the right to set it.


\section{OnBoarding Operation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\note#1{}



\newpage


\section{Q\&A}

\noindent\fbox{
    \parbox{\textwidth}{
    \textcolor{red}{
{\bf Q1, to Massi:}\\
In your notes I found the statement that $TransferType$ is defined in such a way as to guarantee that 
\begin{quote} 
	for each pair of accounts $acc,acc'$ there is at most one $tt \in AccountType$ 
\end{quote}
which would mean with $source(tt)=acc$ and $target(tt)=acc'$ or vice versa. Is this true? Is it not possible to perform a Credit operation from acc to acc' and a Debit operation from acc' to acc?
}}}
\noindent\fbox{
    \parbox{\textwidth}{
{\bf ANSWER:}\\
\textcolor{purple}{(Massi) Yes, we can actually think of the TT as a table. The real implementation in Cyclos has more columns, but the relevant ones for the Sardex business logic are those in this document.}

\vspace{12pt}
\textcolor{purple}{(Massi) Yes, the Sardex business logic guarantees that for each pair of accounts $acc$, $acc'$ there is at most one $tt \in AccountType$ per Operation (so at most 1 credit and 1 debit TT).}

\vspace{12pt}
\textcolor{purple}{(Massi) That means that if $source(tt) = acc$ and $target(tt) = acc'$ and operation is CREDIT, for example, then a transfer goes from $acc$ to $acc'$. If $source(tt) = acc$ and $target(tt) = acc'$ and operation is DEBIT, then the transfer goes from $acc'$ to $acc$.}

\vspace{12pt}
\textcolor{brown}{(Paolo) When discussing this question, I pointed out that these names are potentially confusing, because (as in the last example) they do not match the behaviour. We can introduce two different levels of abstraction: at the lowest level, we are talking about flow of credits. At the level above, we can talk about the Originator of the transaction. One way to express this could be:}
\begin{quote}
\textcolor{brown}{
$acc(CREDIT, originator) = acc(source)$\\
$acc(DEBIT, originator) = acc(target)$}
\end{quote}
\textcolor{brown}{I realise that this is nonsense, or at best some weird form of overloading. How do we express that the same account number can be accessed differently at different levels of abstraction? Or maybe we do not need to and I am thinking about this the wrong way?
}}}

\vspace{24pt}
\noindent\fbox{\parbox{\textwidth}{
{\bf Q2:}\\
\textcolor{red}{Should we worry at this stage that for an executable version of the model we also need a model for the corresponding user actions? For the time being we are formulating only the rules for the Sardex agent.
}}}
\noindent\fbox{\parbox{\textwidth}{
\textcolor{purple}{(Massi) Yes, I think we should worry. Therefore, we should develop a model also for the user actions. In any case, the user agent should be quite simple to model.
}}}

\vspace{24pt}
\noindent\fbox{\parbox{\textwidth}{
{\bf Q3, to Luca/Massi:}\\
\textcolor{red}{How do you want this function to be named?
}}}
\noindent\fbox{\parbox{\textwidth}{
\textcolor{purple}{(Massi) I think the names you chose are good.
}}}

\vspace{24pt}
\noindent\fbox{\parbox{\textwidth}{
{\bf Q4,  to Luca/Massi:}\\
\textcolor{red}{Is this abstraction  correct, namely to compute the transition from the transfer parameter? For DEBIT I included an additional parameter $pending$.
}}}
\noindent\fbox{\parbox{\textwidth}{
\textcolor{purple}{(Massi) Yes, but arguments should be: tt, from, to, amount.}

\vspace{12pt}
\textcolor{green}{
(Luca) I'm not sure about the form, but credit/debit and channel are part of the tt parameters that must match the channel used by the user.}
}}

\vspace{24pt}
\noindent\fbox{\parbox{\textwidth}{
{\bf Q5,  to Luca/Massi:}\\
\textcolor{red}{Do you want the $transferTypeCheck(tt)$ to yield more than ok/notOk to be able to give more details in the ErrMsg, the way shown for balanceCheck? If yes, which details do you want to specify here?
}}}
\noindent\fbox{\parbox{\textwidth}{
\textcolor{purple}{(Massi) In the current implementation there is only an OK / KO message, because the TT can be only exist or not exist. However, you are right that some more feedback would be useful, such as the credit limit ($creditLimit$), the upper limit ($upperLimit$?), and the available balance.
}}}

\vspace{24pt}
\noindent\fbox{\parbox{\textwidth}{
{\bf Q6,  to Luca/Massi:}\\
\textcolor{red}{I think I remember that one of you said that upon receiving the CreditPerformReq the system executes once more the transferTypeCheck. Is this the case or is the result of the previously performed check stored and retrieved? Whatever your answer is, you probably consider this as an important requirement we should express in the ground model?
}}}
\noindent\fbox{\parbox{\textwidth}{
\textcolor{purple}{(Massi) Yes it is very important that all checks are made also in PerformReq, so this requirement should be expressed in the ground model.
}}}

\vspace{24pt}
\noindent\fbox{\parbox{\textwidth}{
{\bf Q7,  to Luca/Massi:}\\
\textcolor{red}{I guess that where a response to a request is expected there is a timeout mechanism to prevent the system from expecting infinitely long for an answer. If this is true and if you want to express it in the spec we should insert a timeout mechanism into the corresponding rule. Please let me know whether I should do this.
}}}
\noindent\fbox{\parbox{\textwidth}{
\textcolor{purple}{(Massi) In the current configuration I don't think there is a explicit timeout for responses to requests at application level but, of course, the infrastructure (network, server, etc.) implements timeout mechanisms at the lower levels. Maybe we could try to model the timeout requirement in a more explicit way.
}}}

\vspace{24pt}
\noindent\fbox{\parbox{\textwidth}{
{\bf Q8,  to Luca/Massi:}\\
\textcolor{red}{Do pending transactions go in the Ledger? For the time being I guess Yes since, when the system is waiting for an $otp$ confirmation that the user is expected to answer, the user may instead try to make another Credit transfer: it could be that only one, Credit or Debit, is still possible due to the user's account balance. But probably the system on this issue offers some more complexity you may want to explain to us.
}}}
\noindent\fbox{\parbox{\textwidth}{
\textcolor{purple}{(Massi) I think the pending transactions should be stored in another table of pending transactions, not in the ledger. Once the pending transaction is confirmed (with the otp) then all balance/permissions/tt checks are re-made, and if all is OK the transaction is finally put in the ledger.
}}}

\vspace{24pt}
\noindent\fbox{\parbox{\textwidth}{
{\bf Q9,  to Luca/Massi:}\\
\textcolor{red}{How much time do you allow between sending the $otp$ and its acknowledgement, in other words for a transaction to remain pending? Is it possible to change channel, using one for CreditPreviewReq and another one for the acknowledgement of the $otp$?
}}}
\noindent\fbox{\parbox{\textwidth}{
\textcolor{purple}{(Massi) It is a configurable parameter per TT. So it depends on the TT. I think the 2 requests (the one for the OTP confirmation and the other for the DebitTransferReq) could be performed on different channels.
}}}

\vspace{24pt}
\noindent\fbox{\parbox{\textwidth}{
{\bf Q10,  to Luca/Massi:}\\
\textcolor{red}{I vaguely remember that there was an issue whether in Debit Request the parameters $from/to$ denote accounts or $members$, but I do not remember what is the case in your system. If from/to are members, the above $from/to$ must become the corresponding account (but which one?) of the members.
}}}
\noindent\fbox{\parbox{\textwidth}{
\textcolor{purple}{(Massi) $from/to$ are members. Because there is at most one TT from each pair of members per operation, and in the TT there is the $account\_type$ $from$ and $account\_type$ $to$, so from a knowledge of $members$ we can easily give the corresponding accounts.
}}}

\vspace{24pt}
\noindent\fbox{\parbox{\textwidth}{
{\bf Q11,  to Luca/Massi:}\\
\textcolor{red}{Can the $counterPty$ parameter indicate besides ALL and a specific account also a set of accounts (or a set of members whose accounts are involved in a transaction)? Or does the parameter anyway indicate not an account but a member? In those cases the rule should be adapted.
}}}
\noindent\fbox{\parbox{\textwidth}{
\textcolor{purple}{(Massi) CounterPty indicates a set of members (one, more then one, or all).}\\
\textcolor{green}{(Luca) I think if we are talking about account we need CounterPty as a set of accounts.}
}}





%\begin{asm}
%\IF \ASM{Member issues}\+
%\ASM{AccountHistReq} (Acc, Period, CntrPty, AmtRange, CustomField)\-
%\THEN \+
%	\IF Acc \not\in Account(Member) \THEN \+
%	 ErrMsg \-
%\ELSE\+
%	\LET
%   T = \{t \in Ledger |\ (from(t) = Acc\ ||\ to(t) = Acc) \+
%	\&\ Date(t) \in Period \\
%	\&\ (\IF CntrPty \neq All \THEN \+
%		CounterParty(t, Acc) \in CntrPty )\-
%	\&\ Amt(t) \in AmtRange \\
%	\&\ Match( CustFld, CustomField(t) ) \} \-
%\ASM{Send} (T, Member)
%\end{asm}

